---
layout: post
title:  "[JAVA] Java 中面向方面编程（AOP）的思想"
date:   2016-08-19
desc: "AOP in Java"
keywords: "java, aspected oriented programming"
categories: [Java]
tags: [Java， AOP]
icon: fa-keyboard-o
---

# 面向方面编程的思想

## I. 面向方面编程

### 1. 什么是方面 Aspect

大家可能知道，很多出名的框架比如 Spring， 里面用到了面向方面编程的思想，那么什么是面向方面编程呢？和学习```面向对象编程 OOP```一样，要先学习 ```对象 Object``` 是什么，那么在```面向方面编程 AOP``` 中，我们要先知道什么是```方面 Aspect```。

```方面```：

-	可以这样理解，如果把对象看作一个圆柱体，那么其中的一个切面，就是一个方面
-	如果系统中存在交叉业务，一个交叉业务，就是要切入到系统的一个方面


我们用个例子来说明，有这么三个类：

-	```StudentService``` 类用来管理学生的增删改查（CRUD）
-	```CourseService``` 类用来管理课程的增删改查
-	```MiscService``` 类用于管理其他东西的功能

我们如果想要在每一个方法调用的时候，加入安全，事务，和日志功能，或者说业务。那么我们可以在每一个方法的开头或者结尾，添加相应的功能。那么就是说，安全，事务，和日志功能贯穿到了好多个模块之中（StudentService， CourseService  ...）, 所以，安全， 事务，和日志就是交叉业务。如下所示

```
					安全           事务          日志
StudentService ------|--------------|------------|-----------
CourseService  ------|--------------|------------|-----------
MiscService    ------|--------------|------------|-----------
```

如果用具体的程序代码来描述交叉业务，就如下所示

```
method1{           method2{				method3{

---------------------------------------------------------- 切面
...                  ...                   ...

---------------------------------------------------------- 切面
}					}					}
```

这些交叉业务，就是要加入到这些切面的位置，比如日志功能。其实这个切面就是 AOP 中所说的方面。

那么问题来了：

-	如果可以更改源代码，那么我们就要对每一个方法进行修改，加入相同的功能
	-	太过麻烦，而且代码复杂，不易维护
-	如果不能对源代码进行修改，又想添加这些功能，怎么办？

由此引出了交叉业务的编程问题，即```面向方面的编程 AOP```


### 2. 面向方面编程的思想

由上面的分析，我们知道，交叉业务，其实都是相同的，比如日志功能。

所以 ```AOP 的思想```：

-	就是把这些交叉业务模块化，形成功能模块，也叫做切面代码
-	将这些切面代码移动到原始方法的周围，这与直接在方法内前后编写切面代码运行效果是一样的

也就是说， 这种交叉业务的模块功能，我只写一份，而不是在每个方法内都要写。


```

---------------------------------------------------------- 切面
method1{           method2{				method3{

...                  ...                   ...

}					}					}
---------------------------------------------------------- 切面

```

现在，我们知道 ```AOP```， 其实就是将交叉业务代码，由原来方法内的切面，移动到方法外的切面，而且，只需要写一次业务代码（切面代码）就行了，那么怎么实现呢？ 用```代理技术```


## II. 代理技术

在学习反射的时候，我们接触过动态代理，这里就详细的说一下代理技术（Proxy）

### 1. 静态代理

静态代理其实就是编写一个与目标类具有相同接口的代理类，代理类的方法调用目标类的相同方法，并添加功能。

可以看下列例子：
定义一个 ```StudentService``` 接口，并定义 CRUD 方法：

```java
package org.lovian.aop.proxy;

public interface StudentService {
	void add();
	void read();
	void delete();
	void update();
}
```

然后增加一个实现类 ```StudentServiceImpl```

```java
package org.lovian.aop.proxy;

public class StudentSerivceImpl implements StudentService{

	@Override
	public void add() {
		System.out.println("add a student");
	}

	@Override
	public void read() {
		System.out.println("read info of a student");
	}

	@Override
	public void delete() {
		System.out.println("remove a student");
	}

	@Override
	public void update() {
		System.out.println("update a student");
	}
}

如果我们想要添加日志功能，那么就写一个代理类，这个代理类中有一个交叉业务模块 ```log()```，由 AOP 的思想，我们这样实现这个代理类：

```java
package org.lovian.aop.proxy;

public class StudentServiceProxy implements StudentService {

	private StudentSerivceImpl ss;

	public StudentServiceProxy() {
		this.ss = new StudentSerivceImpl();
	}

	@Override
	public void add() {
		log();
		ss.add();
	}

	@Override
	public void read() {
		log();
		ss.read();
	}

	@Override
	public void delete() {
		log();
		ss.delete();
	}

	@Override
	public void update() {
		log();
		ss.update();
	}

	private void log() {
		System.out.println("This is log info");
	}
}
```

测试类中，将要使用反射和配置文件来决定是调用原有类还是代理类

```java
package org.lovian.aop.proxy;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Properties;

public class StudentServiceTest {
	public static void main(String[] args) throws Exception{

		InputStream is = new FileInputStream("resource/config.properties");
		Properties props = new Properties();
		props.load(is);
		is.close();

		String className = props.getProperty("className");
		Class<?> c = Class.forName(className);
		StudentService ss = (StudentService) c.newInstance();

		ss.add();
		ss.read();
		ss.update();
		ss.delete();
	}
}
```

配置文件， 位于项目目录下的 ```resource/config.properties```，我们先定义 ```className``` 为 ```StudentSerivceImpl```

```
className = org.lovian.aop.proxy.StudentSerivceImpl
```

测试结果：

```
add a student
read info of a student
update a student
remove a student
```

但如果我们在配置文件中改用代理类

```
className = org.lovian.aop.proxy.StudentServiceProxy
```

测试结果：

```
This is log info
add a student
This is log info
read info of a student
This is log info
update a student
This is log info
remove a student
```

由这个代理的例子我们可以发现，通过配置文件和反射，我们可以非常容易的通过修改配置文件去调用不同的类，而不用修改原有代码。但是这样做有一个问题，就是如果我有很多个实现类，那么我需要为这很多个实现类添加一个代理类，这样做是非常麻烦的，所以就有了动态代理技术

### 2. 动态代理

JVM 可以在运行期动态生成出类的字节码，这种动态生成的类往往被用作代理类，即动态代理类。

-	JVM 生成的动态类必须实现一个或者多个接口
	-	JVM 生成的动态类只能用具有相同```接口```的目标类的代理
-	```CGLIB``` 可以动态生成一个类的子类，一个类的子类也可以用作该类的代理类
	-	如果要为一个```没有实现接口的类```生成动态代理类，可以可以使用```CGLIB```库

代理类的每个方法通常除了要调用目标的相应方法和对外返回目标返回的结果外，还可以在下面四个位置加上系统功能代码

-	在调用目标方法之前
-	在调用目标方法之后
-	在调用目标方法前后
-	在处理目标方法异常的 catch 块中

```
void method(){
	.......... // 调用目标方法前
	try{
		target.method();
	}catch{
		........... // 处理目标方法的异常
	}
	......... // 调用目标方法后
}
```

怎么实现得到动态代理类并调用，查看[[JAVA] Java 类加载器和反射](http://blog.lovian.org/java/2016/08/15/java-reflection.html)


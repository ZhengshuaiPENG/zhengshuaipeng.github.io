---
layout: post
title:  "[JAVA_Spring] AOP Introduction"
date:   2018-05-07
desc: "Spring AOP introduction"
keywords: "java, spring, AOP"
categories: [spring]
---

Spring ```DI``` 和 ```AOP（Aspect Oriented Programming）``` 被称为 Spring 的两大基石， 这篇 post 先介绍一下 Spring AOP。
之前在学习完 Java 的反射以及动态代理之后，大致的讲了一些 AOP 的原理，请参考 POST： [Java 中面向方面编程（AOP）的思想](http://blog.lovian.org/java/2016/08/19/java-aop.html)

# I. 为什么需要 AOP

首先先来看一个需求：有一个计算器的接口和其实现类的 UML 定义如下：

![AOP_1](/assets/blog/2018/05/aop_1.png)

这个计算器功能很简单，能够实现加减乘除的运算

-   需求1 - 日志： 在程序执行期间追踪正在发生的活动
-   需求2 - 验证： 希望计算机只能处理正数的运算

那么拿日志 log 的功能来说，可能我们需要在每个方法中添加log，比如说在 add 方法中：

```java
public int add(int i, int j){
    System.out.println("ADD-Input: i=" + i + " Output: j=" + j);
    int result = i + j;
    System.out.println("Result: " + result);
}
```

同样的在 sub(), mul(), 和 div() 方法也需要打印日志，那么这个日志的方法就会造成大量的字符串拼接和代码冗余。怎么解决这种问题，就同过 AOP 的方式，去添加日志功能，日志功能这里就是一个```切面（ASPECT）```，所以 AOP 也叫```面向切面编程```，其实现之一就是动态代理

## 1.使用动态代理实现 AOP

上面日志的例子说明了两个问题：
-   ```代码混乱```：越来越多的非业务需求(日志和验证等)加入后, 原有的业务方法急剧膨胀.  每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点. 
-   ```代码分散```: 以日志需求为例, 只是为了满足这个单一需求, 就不得不在多个模块（方法）里多次重复相同的日志代码. 如果日志需求发生变化, 必须修改所有模块.

那么我们就可以使用```动态代理```实现 AOP 来解决上述问题。

先复习一下```代理设计模式（Proxy Design Pattern）```的原理：

使用一个代理（Proxy）将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过该代理对象。代理对象决定是否以及何时将方法转到原始对象上。

那么上述计算器的例子使用代理后，图示如下：

![AOP_Proxy_1](/assets/blog/2018/05/aop_proxy_1.png)

关于使用动态代理的原理和使用， 请参考 [Java 动态代理](http://blog.lovian.org/java/2016/08/15/java-reflection.html#tocAnchor-1-1-3)

通过动态代理的方式我们可以不用修改原来对象的业务逻辑就可以给它加上验证功能和日志功能。


# II. AOP 简介

-   ```AOP(Aspect-Oriented Programming, 面向切面编程)```: 是一种新的方法论, 是对传统 ```OOP(Object-Oriented Programming, 面向对象编程)``` 的补充.
-   AOP 的主要编程对象是```切面(aspect)```, 而切面模块化横切关注点.
-   在应用 AOP 编程时, 仍然需要```定义公共功能```, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且```不必修改受影响的类```. 这样一来```横切关注点就被模块化到特殊的对象(切面)里```.
-   AOP 的好处:
    -   每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级
    -   业务模块更简洁, 只包含核心业务代码.

下面通过一个图对上述例子来说明 AOP ：

![AOP_Structure](/assets/blog/2018/05/aop_structure.png)

本来业务逻辑的需求比较复杂和混乱，那么我们把可以通用的部分，也就是横切关注点，抽取出来作为切面，也就是图中的验证功能和日志功能，把业务逻辑分离出来。这样一个复杂的设计就被分离为 ```切面 + 单纯业务逻辑```的组合，这就是面向切面编程的方式

# III. AOP 术语

AOP已经形成了自己的术语，下面来介绍一下这些概念：

-   ```切面(Aspect)```: 
    -   横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象
    -   ```切面时通知和切点的结合```
-   ```通知(Advice)```:  
    -   ```定义了切面是什么和何时使用```
    -   切面必须要完成的工作
    -   ```When```： Advice 解决了何时要完成这个工作，是在某个方法调用之前？之后？之前之后都调用还是在方法抛出异常时调用
    -   Advice 的分类：
        -   前置通知（Before）：在目标方法被调用之前调用通知功能
        -   后置通知（After）：在目标方法被调用后调用通知功能，此时不会关注方法的输出是什么
        -   返回通知（After-returning）：在目标方法成功执行之后调用通知
        -   异常通知（After-throwing）：在目标方法抛出异常后调用通知
        -   环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为
-   ```目标(Target)```: 被通知的对象
-   ```代理(Proxy)```: 向目标对象应用通知之后创建的对象
-  ``` 连接点（Joinpoint）```：
    -   应用过程中能够插入切面的一个点
    -   程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。
    -   例如 ArithmethicCalculator#add() 方法执行前的连接点，执行点为 ArithmethicCalculator#add()； 方位为该方法执行前的位置
-   ```切点（pointcut）```：
    -   每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。AOP 通过切点定位到特定的连接点
    -   类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。
-   ```引入（Introduction）```：
    -   允许向现有类添加新的方法和属性
    -   无需修改现有的类使其具有新的行为和状态
-   ```织入（Weaving）```：
    -   织入时把切面应用到目标对象并创建新的代理对象的过程
    -   切面在指定的连接点被织入到目标对象中
    -   在目标对象的生命周期里有多个点可以进行织入：
        -   ```编译期```：切面在目标类编译时被织入，需要特殊的编译器比如 ```AspectJ```
        -   ```类加载期```：切面在目标类被加载到 JVM 时被织入，需要特殊的 ClassLoader，AspectJ5的加载时织入(load-time weaving, LTW) 就支持该方式
        -   ```运行期```：切面在应用运行的某个时刻被织入。在织入切面时，AOP 容器会为目标动态的创建一个代理对象。 Spring AOP就是以这种方式织入切面的